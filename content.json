{"meta":{"title":"煮酒の博客","subtitle":"欢迎加入","description":"煮酒","author":"煮酒","url":"https://blog.liph.top","root":"/"},"pages":[{"title":"关于我的","date":"2020-07-25T12:34:27.000Z","updated":"2021-04-07T13:30:55.319Z","comments":true,"path":"about/index.html","permalink":"https://blog.liph.top/about/index.html","excerpt":"","text":"关于博主博主是编程学生党一枚，主要学习过如下技术 前端 后端 html,css,js,vue,react,koa,taro,webpack,typescript,Sass，MongoDB JAVA,Servlet2.0/3.0,MySQL,Spring全家桶,Redis,Mybatis,Hibernate,Struts,简单算法,简单数据结构,设计模式"},{"title":"标签","date":"2020-07-25T12:28:15.000Z","updated":"2021-04-07T11:28:49.571Z","comments":true,"path":"tags/index.html","permalink":"https://blog.liph.top/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-07-25T12:29:35.000Z","updated":"2021-04-07T11:28:49.567Z","comments":true,"path":"categories/index.html","permalink":"https://blog.liph.top/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-07-25T12:30:26.000Z","updated":"2021-04-07T11:28:49.569Z","comments":true,"path":"link/index.html","permalink":"https://blog.liph.top/link/index.html","excerpt":"","text":""}],"posts":[{"title":"顺序栈的基本操作","slug":"顺序栈的基本操作","date":"2021-05-22T16:14:55.275Z","updated":"2021-05-22T16:18:39.583Z","comments":true,"path":"posts/60585/","link":"","permalink":"https://blog.liph.top/posts/60585/","excerpt":"","text":"顺序栈的基本操作通过菜单调用各个操作，测试点： 没有初始化前进行其他操作，程序是否能控制住； 初始化一个栈； 判栈空，屏幕显示栈为空； 3个数入栈， 1、2、3； 栈长度，屏幕输出3； 取栈顶元素，再判栈空，然后再判栈长度。让学生知道取栈顶元素不改变栈中的内容，栈顶指针不发生改变； 出栈，再判栈长度； 销毁栈，再做其他操作，判断程序是否能控制； 数制转换，输入：8，输出：1000 问题分析：栈是将插入和删除集中在一端进行的线性结构，表尾端称为栈顶，表头端称为栈底，不含元素的栈称为空栈。 顺序栈是指利用顺序存储结构实现的栈，利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，用指针top指向栈顶元素所在位置的下一位。 顺序栈有以下基本操作：初始化栈、销毁栈、将栈置空、入栈、出栈、判断栈是否为空、删除栈顶元素、求栈的长度、输出栈内元素、创建并初始化栈。 算法思想：栈底指针base始终指向栈底的位置，当base的值为NULL时，百世栈不存在；top为栈顶指针，其初值指向栈底，每当元素入栈时，top指针加1，删除栈顶元素时，top指针减1；当栈为空时，top和base的值相等，都指向栈底；栈非空时，top始终指向栈顶元素的上一个位置。 数制转换的算法思想：将十进制数转换为n进制数，可每次将数除n的余数入栈，然后数除以n，直到该数变为0，再讲栈内元素输出，即可得到转换为n进制后的数。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;#define MAXSIZE 100typedef int SElemType;typedef struct&#123; SElemType *base; SElemType *top; int stacksize;&#125;SqStack;//初始化栈int InitStack(SqStack&amp;S)&#123; S.base=new SElemType[MAXSIZE]; S.top=S.base; S.stacksize=MAXSIZE; return 1;&#125;//判断栈是否为空bool StackEmpty(SqStack S)&#123; if(S.top==S.base) return true; else return false;&#125;//求顺序栈的长度int StackLength(SqStack S)&#123; return S.top-S.base;&#125;//清空顺序栈int ClearStack(SqStack &amp;S)&#123; if(S.base) S.top=S.base; return 1;&#125;//销毁顺序栈int DestroyStack(SqStack &amp;S)&#123; if(S.base) &#123; delete[]S.base; S.stacksize=0; S.base=S.top=NULL; &#125; return 1;&#125;//入栈int Push(SqStack &amp;S,SElemType e)&#123; if(S.top-S.base==S.stacksize) return 0; *S.top++=e; return 1;&#125;//出栈int Pop(SqStack &amp;S,SElemType&amp;e)&#123; if(S.top==S.base) return 0; e=*--S.top; return 1;&#125;//取栈顶元素int GetTop(SqStack S,SElemType&amp;e)&#123; if(S.top==S.base) return 0; e=*(S.top-1); return 1;&#125;//输出栈内元素void print(SqStack S)&#123; while(S.top!=S.base) &#123; cout&lt;&lt;*(S.top-1); S.top--; &#125;&#125;//创建并输入栈元素void BulidStack(SqStack &amp;S,int n)&#123; while(n--) &#123; cin&gt;&gt;*S.top; S.top++; &#125;&#125;//输出提示信息void welcome()&#123; cout&lt;&lt;\"****************\"&lt;&lt;endl; cout&lt;&lt;\"1.初始化为空栈\"&lt;&lt;endl; cout&lt;&lt;\"2.销毁栈\"&lt;&lt;endl; cout&lt;&lt;\"3.将栈置空\"&lt;&lt;endl; cout&lt;&lt;\"4.判断栈是否为空栈\"&lt;&lt;endl; cout&lt;&lt;\"5.返回栈的长度\"&lt;&lt;endl; cout&lt;&lt;\"6.求栈顶元素\"&lt;&lt;endl; cout&lt;&lt;\"7.插入元素，并使其成为栈顶元素\"&lt;&lt;endl; cout&lt;&lt;\"8.删除栈顶元素，并返回其值\"&lt;&lt;endl; cout&lt;&lt;\"9.输出栈内元素\"&lt;&lt;endl; cout&lt;&lt;\"10.创建并输入栈元素\"&lt;&lt;endl; cout&lt;&lt;\"11.退出\"&lt;&lt;endl; cout&lt;&lt;\"12.运行数字转换程序\"&lt;&lt;endl; cout&lt;&lt;\"****************\"&lt;&lt;endl;&#125;bool IsLegal(SqStack S)&#123; if(abs(S.top-S.base)&gt;MAXSIZE) return false; else if(!S.base) return false; else return true;&#125;int main()&#123; SqStack S; SElemType e; int n,mes;// cout&lt;&lt;*S.top&lt;&lt;\" \"&lt;&lt;*S.base;// return 0; welcome(); cout&lt;&lt;\"请输入你的选择&gt;&gt;\"; while(cin&gt;&gt;n) &#123; switch(n) &#123; case 1: mes=InitStack(S); if(mes) cout&lt;&lt;\"初始化成功！\"&lt;&lt;endl; break; case 2: if(!IsLegal(S))&#123; cout&lt;&lt;\"栈未初始化！\"&lt;&lt;endl; break; &#125; mes=DestroyStack(S); if(mes) cout&lt;&lt;\"销毁成功！\"&lt;&lt;endl; break; case 3: if(!IsLegal(S))&#123; cout&lt;&lt;\"栈未初始化！\"&lt;&lt;endl; break; &#125; mes=ClearStack(S); if(mes) cout&lt;&lt;\"栈已置空！\"&lt;&lt;endl; break; case 4: if(!IsLegal(S))&#123; cout&lt;&lt;\"栈未初始化！\"&lt;&lt;endl; break; &#125; if(StackEmpty(S)) cout&lt;&lt;\"栈为空！\"&lt;&lt;endl; else cout&lt;&lt;\"非空！\"&lt;&lt;endl; break; case 5: if(!IsLegal(S))&#123; cout&lt;&lt;\"栈未初始化！\"&lt;&lt;endl; break; &#125; mes=StackLength(S); cout&lt;&lt;\"栈的长度为：\"&lt;&lt;mes&lt;&lt;endl; break; case 6: if(!IsLegal(S))&#123; cout&lt;&lt;\"栈未初始化！\"&lt;&lt;endl; break; &#125; mes=GetTop(S,e); if(mes) cout&lt;&lt;\"栈顶元素为：\"&lt;&lt;e&lt;&lt;endl; else cout&lt;&lt;\"操作失败！\"&lt;&lt;endl; break; case 7: if(!IsLegal(S))&#123; cout&lt;&lt;\"栈未初始化！\"&lt;&lt;endl; break; &#125; cout&lt;&lt;\"请输入一个元素：\"; cin&gt;&gt;e; mes=Push(S,e); if(mes) cout&lt;&lt;\"入栈成功！\"&lt;&lt;endl; else cout&lt;&lt;\"操作失败！\"&lt;&lt;endl; break; case 8: if(!IsLegal(S))&#123; cout&lt;&lt;\"栈未初始化！\"&lt;&lt;endl; break; &#125; mes=Pop(S,e); if(mes) cout&lt;&lt;\"栈顶元素为：\"&lt;&lt;e&lt;&lt;endl; else cout&lt;&lt;\"操作失败！\"&lt;&lt;endl; break; case 9: if(!IsLegal(S))&#123; cout&lt;&lt;\"栈未初始化！\"&lt;&lt;endl; break; &#125; print(S); cout&lt;&lt;endl; break; case 10: cout&lt;&lt;\"请输入要初始化的元素个数：\"; cin&gt;&gt;mes; cout&lt;&lt;\"请输入\"&lt;&lt;mes&lt;&lt;\"个元素：\"&lt;&lt;endl; BulidStack(S,mes); break; case 11: return 0; break; case 12: cout&lt;&lt;\"请输入要转换的数字：\"; cin&gt;&gt;e; InitStack(S); while(e) &#123; Push(S,e%2); e/=2; &#125; print(S); cout&lt;&lt;endl; break; default: cout&lt;&lt;\"操作有误！\"&lt;&lt;endl; &#125; cout&lt;&lt;\"请输入你的选择&gt;&gt;\"; &#125; return 0;&#125; 运行结果","categories":[],"tags":[]},{"title":"HDFS常用操作命令","slug":"HDFS常用操作命令","date":"2021-05-22T16:14:34.564Z","updated":"2021-05-22T16:18:39.580Z","comments":true,"path":"posts/4768/","link":"","permalink":"https://blog.liph.top/posts/4768/","excerpt":"","text":"HDFS Shell 实践（1） 列举一个目录的所有文件 （2） 创建文件夹 （3） 将本地文件上传至HDFS )（4） 将本地文件从HDFS下载到本地文件系统 （5） 查看文件内容 （6） 删除文件或者文件夹","categories":[],"tags":[]},{"title":"Spark的安装部署","slug":"Spark的安装部署","date":"2021-05-22T16:14:30.271Z","updated":"2021-05-22T16:18:39.582Z","comments":true,"path":"posts/23767/","link":"","permalink":"https://blog.liph.top/posts/23767/","excerpt":"","text":"1.将安装包拖入到Linux虚拟机的桌面，然后进入桌面所在的文件路径，使用如下命令对Spark进行解压和重命名等操作) 通过如下Linux命令进入Spark解压文件中的conf文件夹，并根据Spark自带的模板创建spark-env.sh配置文件 3. 通过在Linux终端使用命令“vim spark-env.sh”修改配置文件spark-env.sh。在配置文件的空白处，添加如下内容,换成自己的路径)4. 在spark-env.sh修改完成之后，我们进一步配置Spark的环境变量。使用如下命令打开当前用户根目录下的配置文件)5.在Linux终端通过如下命令来启动Spark，并查看Master和Worker进程是否启动)","categories":[],"tags":[]},{"title":"Spark基本原理总结","slug":"Spark基本原理总结","date":"2021-05-22T16:14:24.296Z","updated":"2021-05-22T16:18:39.582Z","comments":true,"path":"posts/25818/","link":"","permalink":"https://blog.liph.top/posts/25818/","excerpt":"","text":"Spark概述Spark由AMP实验室与2009年开发，有以下四个特点： 运行速度快使用有向无环图（DAG）执行引擎，基于内存速度比Hadoop 快百倍，基于磁盘速度快10倍 容易使用支持Scala、Java、Python、R 通用性提供强大完整的技术栈：SQL查询、流式计算、机器学习、图算法等 运行模式多样Scala简介一门现代的多范式编程语言，运行于JVM，兼容Java具有以下优点： 强大的并发性，支持函数式编程，更好支持分布式系统 语法简洁，API易用 兼容Java，速度快，融入到Hadoop生态圈Spark与Hadoop的对比Hadoop的缺点：表达能力有限、磁盘IO开销大、延迟高 Spark的优点：编程模型更灵活、更高的迭代运算效率、基于DAG的任务调度执行机制、更有的迭代执行机制 Spark生态系统：Spark Core、Spark SQL、MLlib、GraphX Spark运行架构基本概念 RDD：弹性分布式数据集，提供一种高度受限的共享内存模型 DAG：有向无环图，反映RDD之间的依赖关系 Executor:运行在工作节点（Worker Node）的一个进程，运行任务并存储数据架构设计Spark包括集群资源管理器、工作节点、任务控制节点、执行进程，关系如下：Executor的优点：利用多线程执行任务，减少启动开销；包含BlockManager存储模块，将内存和磁盘共同作为存储设备，减少IO开销Spark运行基本流程RDD的设计与运行原理RDD概念弹性分布式数据集，Spark所定义的一种抽象数据类型，是对Spark中的一个只读数据集合的逻辑描述 分装了Spark数据集合的分区列表、分区在集群中的位置、与其他RDD的衍生关系及对数据集合的相关操作，但不包含数据集合的具体数据。 只能通过来自HDFS、Hbase等数据源的数据进行创建或通过对其他RDD计算得到 RDD主要属性1.数据的分区列表每个分区对应集群中的一个物理数据块，可以由一个单独的节点进行处理，分区是Spark计算的基本单元，分区的大小决定了Spark的计算粒度。 用户可在创建RDD时指定RDD的分区个数，默认为程序所分配到的CPU Core的数目。 2.计算每个分区的函数RDD只能通过数据源创建或通过其他RDD转换的到计算函数记录了RDD在转换过程中对父RDD所做的操作 如果RDD是通过已有的文件系统构建，则计算函数读取指定文件系统中的数据 3.与其他RDD之间的依赖RDD每次转换会生成一个新的RDD，RDD之间的关系类似于流水线的前后衍生血缘关系 RDD通过记录自己与其他RDD之间的血缘依赖关系，在部分数据丢失时，可以通过重新计算来回复丢失的分区 4.优先列表位置记录了每个分区的优先位置通过HDFS的数据来建立RDD时，这个列表保存的就是每个分区对应的数据块的位置移动数据不如移动计算，Spark进行任务调度时，会尽可能将计算任务分配到所要处理的数据块的存储位置 5.分区策略RDD的分区函数分区函数决定RDD分区的个数 6.RDD的两类操作 转换操作由一个RDD经过操作得到一个新的RDD转换操作在Spark中都是惰性的，Spark遇到这类操作时不会立即执行新生成的RDD会记录转换的相关信息。 动作操作动作操作一般用于向Driver进程返回结果或者写入结果到文件中。这些操作都封装在RDD抽象数据类型中，可以通过RDD对象的方法调用来使用这些方法。会触发一次Spark中一次Job作业的提交。Spark会根据前面记住的RDD转换过程及RDD之间的衍生关系，建立RDD有向无环图DAG，然后将DAG划分为不同的阶段，产生具体的任务集合，建立RDD有向无环图DAG，然后将DAG划分为不同的阶段，产生具体的任务集合，并将具体的任务分发给不同的Executor去执行。6.RDD的常见转换操作Map操作：将输入的RDD中的每个元素，根据map函数中传递进来的func函数进行处理，输入的RDD有多少个分区，输出RDD也有多少个分区。 flatMap操作：根据传递的func函数对输入RDD的每个元素进行处理。需要将各个元素的处理结果进行扁平化处理，即将各个元素的处理结果合并成一个集合。 Union操作：将两个RDD中的元素进行合并，形成一个新的RDD，要求进行合并操作的两个RDD中元素的数据类型相同。 fliter操作：根据传递进来的func函数对输入RDD中的数据进行过滤。传递进来的func函数的输出值为true或者false的布尔值。应用输入函数对输入RDD中的每个元素进行处理，结果为true的元素将被保留 distinct操作：将输入RDD中的元素进行去重处理，也就是将输入RDD中重复的元素去除。 groupByKey操作：groupByKey操作要求输入的RDD中的元素是&lt;key, value&gt;形式的数据，该操作将输入RDD中key相同的元素合并成一个&lt;key, Iterable&lt;value1, value2,value3&gt;&gt;形式的元素。 reduceByKey(func)操作： 要求输RDD中的元素具有&lt;key, value&gt;的形式。将输入RDD中具有相同key的元素的value值根据传递进来的func函数进行聚合处理。 Join操作：要求当前RDD和通过参数输入的RDD都是&lt;key, value&gt;形式的数据集合，将两个RDD下相同key值对应的value值聚合为一个集合。 持久化操作：通过持久化操作来保存中间操作的结果，持久化操作的具体操作函数有两个：persist和cache。 Reduce操作：当前RDD的元素从左至右根据传递进来的func函数进行两两运算，并将计算结果与RDD中的下一个元素进行相同的计算，直到遍历完RDD的所有元素。 Spark的map操作与MapReduce的map操作相同，但是Spark的reduce操作与MapReduce的reduce操作不同。 7.RDD的依赖关系RDD操作中原RDD与目标RDD之间的父子血缘关系关系称为RDD之间的依赖关系。RDD操作中原RDD与目标RDD之间的父子血缘关系关系称为RDD之间的依赖关系。 窄依赖父RDD的每一个分区最多被一个子RDD的分区所用。一个父RDD的一个分区不可能对应一个子RDD的多个分区 宽依赖子RDD的分区依赖于父RDD的多个分区或所有分区。存在一个父RDD的一个分区对应一个子RDD的多个分区8.RDD的容错机制： 对于窄依赖来讲，在恢复子RDD中某个丢失的分区时，只需要找到其父RDD的对应分区，然后根据子RDD中记录的操作重新进行计算即可。 而对于宽依赖来说，恢复子RDD分区的容错处理机制则将重新计算父RDD的所有分区数据，相对于窄依赖中的容错处理过程来说将会产生冗余计算。","categories":[],"tags":[]},{"title":"Hbase常用操作命令","slug":"Hbase常用操作命令","date":"2021-05-22T16:14:17.612Z","updated":"2021-05-22T16:18:39.581Z","comments":true,"path":"posts/63687/","link":"","permalink":"https://blog.liph.top/posts/63687/","excerpt":"","text":"（1）进入hbase shell在启动HDFS和Hbase之后，在Linux客户端输入“hbase shell”命令将进入Hbase Shell。打开Hbase Shell之后，首先输入“help”命令，Hbase Shell会显示Hbase所提供的所有Shell命令。 （2）创建、查看、删除命名空间建立一个test的命名空间可以通过如下describe命令来查看所建立的命名空间的详细信息我们也可以通过如下命令来查看当前Hbase中所有的命名空间通过如下命令来删除一个命名空间 （3）创建、查看、删除表以及使表有效和无效建立一个usr_beha表，有两个列族，一个是beha，一个是attr，具体的命令如下，创建表时至少有一个列族输入list命令就可以看到如下信息，显示usr_beha表已经创建。List命令显示当前Hbase中所有的表的信息输入describe ‘usr_beha’命令，就可以看到如下信息describe命令用于显示一个表的结构与设置信息可以让我们看到关于一个表的一些默认的设置关于列族的属性信息我们也可以在创建表时通过以下方式进行明确的设置)删除一个表使用drop命令，比如删除我们创建的usr_beha表，具体的命令格式如下：（需首先使用disable命令使该表失效）在创建表时指定表所属的命名空间，则可以使用如下命令查看一个命名空间下的所有表格信息，可以使用如下命令 （4）添加、获取、删除单元格添中的数据向表usr_beha中写入ID为38932423的用户张三的姓名格式：put 表名，行键，列族，数据通过如下命令来查看刚刚写入的数据：格式：get 表名，行键，列族 通过scan命令来查看整个表的信息)删除上述单元格的数据，则可以使用delete命令格式：delete 表名，行键，列族 （5）修改表的结构在刚创建的表usr_beha中添加一个新的列族ecf1：删除一个表中的列族 （6）退出Hbase shell退出Hbase Shell使用exit命令 （7）查看Hbase集群的状态使用status命令，并可以根据summary、simple和detailed这几个关键词来获取不同详细程度的状态信息","categories":[],"tags":[]},{"title":"第一次考核常见问题及知识点总结","slug":"第一次考核常见问题及知识点总结","date":"2021-04-08T06:18:51.000Z","updated":"2021-05-22T15:40:04.523Z","comments":true,"path":"posts/58104/","link":"","permalink":"https://blog.liph.top/posts/58104/","excerpt":"","text":"第一次考核已经结束，我们也看了大家的作业，总体来说基本大模样都能写出来，但都存在着这样那样的小问题，大家刚接触这也很正常，下面汇集了大家常见的问题，希望能对大家有所帮助 问题1. 图片写成绝对路径，导致发来的作业我们打开看不到你的图片例如路径写成&lt;img src= &quot;C:/Users/test/Documents/images/logo.png&quot;&gt;而发来后我们打开网页，网页会去找我们的C盘下的这个文件，而我们C盘又没有这个文件导致图片不能显示。解决方法：以后图片路径一律写成相对路径，如../images/logo.png这样也方便移动文件后也能正常打开。 2.文件夹层次较乱部分同学所有文件在同一文件夹下，这样就会显着很没有层次，以后文件会很多就会显得杂乱无章解决方法:图片统一在images(也可以取其他名字，但要能一看就知道是放图片的)文件夹下类似的文件统一在一个文件夹下这种，css放到单独的css文件夹下，下面提供一种方案。 3. 缩放后跑到一个方向而不是居中如何快速缩放：按住Ctrl键滚动鼠标放大缩小例如下面这种，缩小后内容跑到一边，另一边留下大面积空白 解决方法：margin:auto；让其自动居中，具体实现另行讲解。 4. 字体颜色距离与原图差异较大如果字体距离与原图不同但界面美观也行，但部分同学因字体颜色距离等因素导致界面看起来不美观。目前大家处于模仿阶段，务必做到与原图一模一样，不要觉得差不多就退而求其次。这是非常严重的问题。解决方法：仔细对比原图，我个人用qq自带截图Ctrl+Alt+A，找到需要的颜色的rgb值，然后使用rgb格式加上颜色，例如color:rgb(123,123,123)双击数值然后按住键盘上的上下可即时调节(在网页上可即时看到效果) 5. 出现横向滚动条了怎么办看了下很多人出现了这个问题，原因大多是比如你用了太大的宽度让他沾满整个屏幕，如果你用的台式机显示正常，你看着挺好，但是比如我电脑14寸的，宽度总共就1000多px，你来个500不出问题才怪。按住F12选中某个盒子是经常用到的排查错误的方式解决方法： 按F12然后点击左边的小鼠标（google chrome快捷键Ctrl+Shift+C）放到右面空白的地方看看是哪个div太宽了导致出现滚动条 根本解决方法是margin:auto配合左右浮动+外层用百分比 6.css代码放到html文件里并不是说css和html放一起就是错的，而是如果css代码较多就会显得文章比较乱（假想你要向下一直滑才能看到你的html代码是什么感觉）放一个文件里只适合css代码较少这样比较好维护解决方法：采用引用外部文件的形式 7.好多同学都是用table写的并不是说用table写是错的，而是table一方面不容易维护，一些框架也都是用div加其他的完成的，日后除后端表格外一般不会用到table解决方法：强烈建议大家用div写 8.咨询建议是固定在窗口固定位置的部分同学的咨询建议那不会随着页面滚动而改变位置解决方法：参考下源码中的效果，主要就是position: fixed; 9.部分同学写死宽度这里指的是比如你写一个盒子宽1500px,你的电脑比较宽看着没问题，但是放到小点的电脑1500px太宽了就会出现滚动条 解决方法：对于较大的宽度用百分比表示(一般在&lt;head&gt;、&lt;footer&gt;这种外层框架才会用到) 知识点1. margin:0 auto；配合左右浮动红色框的宽度固定假如为1000px;再加个margin: 0 auto; 让红色框水平方向居中；再加个overflow: hidden;清除文档流的浮动，避免红色框以外的元素随着里面元素的浮动里面的两个黑色框宽度固定但不要超过父元素宽度，一个float:left, 一个float:right;如果黑色框里还有这种左右结构，可以继续将其进行拆分按照这个方式 布局就能让网页在不同大小的屏幕（电脑屏幕）或不同浏览器上浏览排版不乱 2.浮动float浮动在初学时可能好多锅都是因为没用好浮动，比如怎么盒子高度为0。具体参考CSS浮动：W3school的css浮动 3.改了代码却不生效这种问题可能是代码没写好，但有时代码没什么问题，却还是不生效。这是因为浏览器的缓存机制的问题。浏览器为了节省流量和更快的打开网页，在用户多次刷新时并不会重新刷新所有文件，而只是刷新部分文件，这就导致可能你改动的代码并未被浏览器重新引用。解决方法：清除浏览器数据 也可在网页界面按快捷键Ctrl+F5谷歌浏览器是这样，其他浏览器类似 4.如何自适应我看了下大多数人都没有用到margin:auto,可能你是用的padding-left或margin-left或绝对定位（虽然可以居中,但是麻烦）使得在你自己电脑上看着好像居中了。比如下面这张图: 左边的logo部分就用的padding-left:130px;,在你的电脑上看着距离挺合适和原图差不多。 但是当你缩放时这时logo这部分距离左边仍然是130px,这就会造成整体左移. 那如何让它居中呢，这时缩放时你应该让它距左边不能是130px了，而应该是一个更大的值，但是如果你写死宽度，就不能做到然他自动变化，所以就要用到margin:auto.具体怎么用margin:auto参考左右浮动布局讲解或网上自行查找资料（必须学会用居中！！！） 小结本篇文章并不能包含所有大家遇到的问题，有些问题也需要大家自己去搜索解决。文章为个人经验所写，如有错误，可在评论区留言，祝大家学习愉快。","categories":[],"tags":[]},{"title":"Hadoop MapReduce概述","slug":"Hadoop MapReduce概述","date":"2021-04-08T06:10:16.304Z","updated":"2021-05-22T15:36:18.212Z","comments":true,"path":"posts/42300/","link":"","permalink":"https://blog.liph.top/posts/42300/","excerpt":"","text":"概述MapReduce是一种并行编程模型，用于大规模数据集的并行运算，将复杂的、运行于大规模集群上的并行计算过程高度抽象到两个函数：Map和Reduce，极大的方便了分布式编程工作，对不会分布式并行编程的人员十分友好。 MapReduce将复杂的、运行于大规模集群上的并行计算过程高度抽象到两个函数：Map和Reduce，在MapReduce中，一个存储在分布式文件系统中的大规模数据集会被切分成许多独立的数据块，这些数据块可以被多个Map任务并行处理。需要注意的是，适合用MapReduce来处理的数据集需要满足一个前提条件：待处理的数据集可以分解成许多小的数据集，而且每一个数据集都可以完全并行地进行处理。 MapReduce的一个设计理念是“计算向数据靠拢”，而不是“数据向计算靠拢”，因此，在一个集群中，MapReduce会尽量将Map程序就近的在HDFS数据所在的节点运行，即将计算节点和存储节点放在一起运行，从而减少了节点间的数据移动。 MapReduce工作流程MapReduce的核心思想可以用“分而治之”来形容，即把大量的数据集拆分成多个小的数据块在多台机器上并行处理，以下是MapReduce执行的过程： 使用InputFormat模块做Map前的预处理，比如验证输入的格式是否符合输入定义，然后将文件切分成逻辑上的多个InputSplit（MapReduce对文件进行处理和运算的输入单位，只是一个逻辑概念，并没有对文件做实际切割，只是记录了要处理的数据的位置和长度）。 通过RecordReader根据InputSplit中的信息来处理InputSplit中的具体记录，加载数据并转换为适合Map任务读取的键值对，输入给Map任务。 Map任务根据用户自定义的映射规则，输出一系列的&lt;key,value&gt;作为中间结果。 对Map的输出进行一定的分区（Portition），排序(Sort)，合并(Combine)，归并（Merge），得到&lt;key,value-list&gt;形式的中间结果，以使Reduce可以并行的处理Map的结果，从无序的&lt;key,value&gt;到有序的&lt;key,value-list&gt;,这个过程称为Shuffle。 Reduce以一系列的&lt;key,value-list&gt;中间结果作为输入，执行用户定义的逻辑，输出结果给OutputFormat模块。 OutputFormat模块验证输出目录是否已经存在及输出结果类型是否符合配置文件中的配置类型，验证通过则输出Reduce的结果到分布式文件系统。 Shuffle过程Shuffle是指对Map输出结果进行分区、排序、合并等处理并交给Reduce的过程，分为Map端的Shuffle过程和Reduce端的Shuffle过程。 Map端的Shuffle过程Map端的Shuffle过程包括四个过程： 输入数据和执行Map任务Map任务接受&lt;key,value&gt;作为输入后，按一定的映射规则转换成一批&lt;key，value&gt; 写入缓存每个Map任务都会被分配一个缓存，Map的输出结果首先写入缓存，在缓存中积累一定数量的Map输出结果后，在一次性批量写入磁盘，在写入缓存之前，key和value值都会被序列化成字节数组 溢写（分区、排序和合并）MapReduce的缓存容量有限，当缓存中的Map结果不断增加时，需要启动溢写操作，将缓存中的内容一次性写入磁盘，并清空缓存，不能等到缓存全部沾满后才启动溢写过程，一般会设置一个溢写比例，如0.8，当缓存占用空间达到这个比例时，就启动溢写操作。在溢写到磁盘之前，缓存中的数据需经历一下几个过程：分区、排序、合并（可选）。MapReduce通过Partitioner接口对键值对进行分区，将Map的结果均匀的分配到Reduce任务进行并行处理，MapReduce允许用户通过重载Partitioner接口来自定义分区方式。对于每个分区内的所有键值对，后台线程会根据key对他们进行内存排序。排序结束后，包含一个可选的合并（Combine）操作，只有在用户定义了Combiner函数时，才会进行合并操作，将具有相同key的&lt;key,value&gt;的value求和，以减少键值对的数量。 文件归并每次溢写操作都会在磁盘中生成一个溢写文件，溢写文件的数量会随着MapReduce任务的执行而越来越多，在Map任务全部结束之前，系统会对所有溢写文件中的数据进行归并，将具有相同key的键值对归并成一个新的键值对，生成一个大的溢写文件。Reduce端的Shuffle过程相对于Map端的Shuffle过程，Reduce端的Shuffle过程更为简单，只需从Map端读取Map结果，并执行归并操作，然后输送给Reduce任务进行处理Reduce端的Shuffle过程包括三个步骤： “领取”数据Map端的Shuffle过程结速后，Reduce任务需要把Map的输出结果“领取”（fetch）来存放到自己所在机器的本地磁盘上，在Reduce任务真正开始前，大部分时间都在从Map端“领取”属于自己处理的分区数据。 归并数据从Map端领回的数据首先被存放在Reduce任务所在机器的缓存中，当缓存被沾满时，数据会被溢写到磁盘中，在溢写过程中会进行与Map端的shuffle过程类似的排序和合并操作。 把数据输入给Reduce任务磁盘中经过多轮归并后得到若干个大文件，不会继续归并成一个新的大文件，而是直接输入给Reduce任务，以减少磁盘读写开销","categories":[],"tags":[]},{"title":"科学上网教程","slug":"科学上网教程","date":"2021-04-07T11:28:49.565Z","updated":"2021-05-22T15:40:12.191Z","comments":true,"path":"posts/45527/","link":"","permalink":"https://blog.liph.top/posts/45527/","excerpt":"","text":"说明科学上网：即翻墙访问外网，本教程仅介绍免费翻墙技巧，在速度和流量上有限制，但是不追求YouTube 4K画质够用了，白嫖党的福利，氪金大佬可充钱，这里主要介绍我目前在用的V2ray 速度截图这是YouTube 4K视频的速度，这个速度相当不错了，全程无卡顿，在GitHub下载文件也是相当快，可以满足大部分需求 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传 服务器节点V2ray主要使用各种服务器节点，有许多经销商，一般都有免费的节点，追求速度的可以氪金 接下来就是几个现在常用的提供商，大家看那个好用就用那个，一般是一个节点不行了就换一个 自由人士免费节点： 注册链接：http://freeperson.xyz/auth/register CLAPSE注册送10G，7天后流量清零，过期后可选择3块或6块一个月的套餐，相对来说比较便宜 我的已经过期了，就不放截图了 注册链接：https://www.clapse.com/ MGNB注册送300g，两天后到期，不用代理，续费一月五毛，速度很快 免费节点： 注册链接：https://mgnb.vip/#/register 小塞 SEBS注册送20G,有效期20天 注册链接：https://ggboom.site/ 节点使用教程有了服务器节点，怎么用呢，慢慢往下看 客户端下载下载V2ray客户端，解压后找到V2ray.exe双击即可打开代理，建议发送快捷方式到桌面 点我下载客户端 配置节点下载好后去复制订阅链接，这里使用自有人士 复制订阅链接后粘贴到浏览器网址栏，下载txt文档，Ctrl+A复制txt文档中的内容，打开V2ray程序，右击，选择从剪贴板批量导入URL 再次右击V2ray程序，即可选择服务器，选择其中一个即可实现科学上网 寻找服务器节点的方法以上节点是在YouTube上看到的，类似的还有很多，有需求的可以自己去搜，有很多人专门分享的 SSRssr俗称小飞机，和V2ray类似，但是V2ray目前比较稳定，这里就不对ssr作介绍了 写在最后很多服务器节点每天签到送流量，大家可以偶尔签到，不然流量可能不够用 以上教程为电脑端使用，手机端上述节点提供商也有相应程序可以下载，可以使用同样的节点 写在最后 很多服务器节点每天签到送流量，大家可以偶尔签到，不然流量可能不够用 以上教程为电脑端使用，手机端上述节点提供商也有相应程序可以下载，可以使用同样的节点 在配置过程中，大家有什么问题可以在评论区留言","categories":[],"tags":[]},{"title":"sublime 、 vscode 快捷生成HTML代码","slug":"sublime 、 vscode 快捷生成HTML代码","date":"2021-04-07T11:28:49.564Z","updated":"2021-05-22T15:36:06.664Z","comments":true,"path":"posts/3541/","link":"","permalink":"https://blog.liph.top/posts/3541/","excerpt":"","text":"文章转载自https://www.cnblogs.com/suitongyu/p/12043791.html 基本html结构输入 !+Enter 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 生成div加类名的快捷键输入 div.list&gt;div.item_$*6 12345678&lt;div class=\"list\"&gt; &lt;div class=\"item_1\"&gt;&lt;/div&gt; &lt;div class=\"item_2\"&gt;&lt;/div&gt; &lt;div class=\"item_3\"&gt;&lt;/div&gt; &lt;div class=\"item_4\"&gt;&lt;/div&gt; &lt;div class=\"item_5\"&gt;&lt;/div&gt; &lt;div class=\"item_6\"&gt;&lt;/div&gt;&lt;/div&gt; 带类名的div输入 div.wrapper 1&lt;div class=\"wrapper\"&gt;&lt;/div&gt; 带id的divdiv#wrapper 1&lt;div id=\"wrapper\"&gt;&lt;/div&gt; 属性 []span[title=”test”] 1&lt;span title=\"test\"&gt;&lt;/span&gt; 后代 &gt;输入div&gt;span&gt;a 1&lt;div&gt;&lt;span&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt; 兄弟 +div+p+span 123&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;span&gt;&lt;/span&gt; 上级 ^div&gt;span^i 12&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;i&gt;&lt;/i&gt; 乘法 *ul&gt;li*2 1234&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 文本 {}div&gt;span{this is test} 1&lt;div&gt;&lt;span&gt;this is test&lt;/span&gt;&lt;/div&gt; 自增符 $ul&gt;li.list_${list $}*3 12345&lt;ul&gt; &lt;li class=\"list_1\"&gt;list 1&lt;/li&gt; &lt;li class=\"list_2\"&gt;list 2&lt;/li&gt; &lt;li class=\"list_3\"&gt;list 3&lt;/li&gt;&lt;/ul&gt; ul&gt;li.item$@3*3 “@3” （表示从3开始计数） 12345&lt;ul&gt; &lt;li class=\"item3\"&gt;list 1&lt;/li&gt; &lt;li class=\"item4\"&gt;list 2&lt;/li&gt; &lt;li class=\"item5\"&gt;list 3&lt;/li&gt;&lt;/ul&gt; 隐式转换.class 1&lt;div class=\"class\"&gt;&lt;/div&gt; ul&gt;.item 123&lt;ul&gt; &lt;li class=\"item\"&gt;&lt;/li&gt;&lt;/ul&gt; table&gt;.row&gt;.col 12345&lt;table&gt; &lt;tr class=\"row\"&gt; &lt;td class=\"col\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;","categories":[],"tags":[]},{"title":"数据结构——单链表的基本操作","slug":"数据结构——单链表的基本操作","date":"2021-04-07T11:28:49.564Z","updated":"2021-05-22T15:40:17.345Z","comments":true,"path":"posts/14136/","link":"","permalink":"https://blog.liph.top/posts/14136/","excerpt":"","text":"实验目的通过该实验，深入理解链表的逻辑结构、物理结构等概念，掌握链表基本操作的编程实现，熟练掌握C语言中指针的操作。 实验内容编程实现链表下教材第二章定义的线性表的基本操作，最好用菜单形式对应各个操作，使其编程一个完整的小软件。 参考界面： 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389#include &lt;iostream&gt;using namespace std;typedef int ElemType;typedef struct LNode&#123; ElemType data; struct LNode *next;&#125;LNode,*LinkList;//链表初始化int InitList(LinkList &amp;L)&#123; L=new LNode; if(!L) return 0; L-&gt;next=NULL; return 1;&#125;//销毁链表int DestoryList(LinkList &amp;L)&#123; LinkList p; while(L) &#123; p=L; L=L-&gt;next; delete p; &#125; return 1;&#125;//清空单链表int ClearList(LinkList L)&#123; LinkList p,q; p=L-&gt;next; while(p)&#123;q=p;delete q;p=p-&gt;next;&#125; L-&gt;next=NULL; return 1;&#125;//求单链表长度int Listlength(LinkList L)&#123; int sum=0; LinkList p=L-&gt;next; while(p) &#123; p=p-&gt;next; sum++; &#125; return sum;&#125;//判断单链表是否为空bool ListEmpty(LinkList L)&#123; if(L-&gt;next) return 1; else return 0;&#125;//获取单链表中某个数据元素的内容int GetElem(LinkList L,int i,ElemType &amp;e)&#123; LinkList p=L-&gt;next; int j=1; while(p&amp;&amp;j&lt;i) &#123; p=p-&gt;next; ++j; &#125; if(!p||j&gt;i)return 0; e=p-&gt;data; return 1;&#125;//查找值为e的数据元素的位置int LocateElem(LinkList L,ElemType e)&#123; LinkList p=L-&gt;next; int i=0; while(p&amp;&amp;p-&gt;data!=e) &#123; p=p-&gt;next; i++; &#125; if(i&gt;=Listlength(L)) return 0; return i+1;&#125;//求直接前驱int PriorElem(LinkList L,ElemType e,ElemType&amp;pre_e)&#123; LNode*p=L-&gt;next; if(e==p-&gt;data) return 0; while(p-&gt;next) &#123; if(p-&gt;next-&gt;data==e) &#123; pre_e=p-&gt;data; return 1; &#125; p=p-&gt;next; &#125; return 0;&#125;//求直接后继int NextElem(LinkList L,ElemType e,ElemType&amp;next_e)&#123; LNode*p=L-&gt;next; while(p) &#123; if(p-&gt;data==e&amp;&amp;p-&gt;next) &#123; next_e=p-&gt;next-&gt;data; return 1; &#125; p=p-&gt;next; &#125; return 0;&#125;//在单链表中插入数据元素int ListInsert(LinkList&amp;L,int i,ElemType e)&#123; LinkList p=L; int j=0; while(p&amp;&amp;(j&lt;i-1)) &#123; p=p-&gt;next; ++j; &#125; if(!p||j&gt;i-1)return 0; LinkList s=new LNode; s-&gt;data=e; s-&gt;next=p-&gt;next; p-&gt;next=s; return 1;&#125;//删除单链表中第i个元素，返回第i个元素的值int ListDelete(LinkList &amp;L,int i,ElemType&amp;e)&#123; LinkList p=L; int j=0; while((p-&gt;next)&amp;&amp;(j&lt;i-1)) &#123; p=p-&gt;next; ++j; &#125; if(!(p-&gt;next)||(j&gt;i-1)) return 0; LinkList q=p-&gt;next; e=q-&gt;data; p-&gt;next=q-&gt;next; delete q; return 1;&#125;//输出链表元素void LinkPrint(LinkList &amp;L)&#123; LinkList p=L-&gt;next; while(p) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;\" \"; p=p-&gt;next; &#125;&#125;//前插法创建单链表void CreateList_H(LinkList &amp;L,int n)&#123; L=new LNode; L-&gt;next=NULL; cout&lt;&lt;\"请输入要插入的元素:\"&lt;&lt;endl; for(int i=0;i&lt;n;i++) &#123; LNode*p=new LNode; cin&gt;&gt;p-&gt;data; p-&gt;next=L-&gt;next; L-&gt;next=p; &#125;&#125;//后插法创建单链表void CreateList_R(LinkList&amp;L,int n)&#123; L=new LNode; L-&gt;next=NULL; LNode*r=L; for(int i=0;i&lt;n;++i) &#123; LinkList p=new LNode; cin&gt;&gt;p-&gt;data; p-&gt;next=NULL; r-&gt;next=p; r=p; &#125;&#125;//判断链表是否为空bool IsEmpty(LinkList L)&#123; if(L-&gt;next) return false; else return true;&#125;//链表逆转int ReverseList(LinkList&amp;L)&#123; if(L==NULL||L-&gt;next==NULL) return 0; LinkList pRev=NULL; LinkList pCur=L-&gt;next; while(pCur!=NULL) &#123; LinkList temp=pCur; pCur=pCur-&gt;next; temp-&gt;next=pRev; pRev=temp; &#125; L-&gt;next=pRev; return 1;&#125;void PrintTips()&#123; cout&lt;&lt;\"可执行的操作有：\"&lt;&lt;endl; cout&lt;&lt;\"********************\"&lt;&lt;endl; cout&lt;&lt;\"1.初始化或重置列表\"&lt;&lt;endl; cout&lt;&lt;\"2.销毁链表\"&lt;&lt;endl; cout&lt;&lt;\"3.链表中数据元素的个数\"&lt;&lt;endl; cout&lt;&lt;\"4.所指位序的元素值\"&lt;&lt;endl; cout&lt;&lt;\"5.链表已存在元素的位序\"&lt;&lt;endl; cout&lt;&lt;\"6.请输入元素，求直接前驱\"&lt;&lt;endl; cout&lt;&lt;\"7.请输入元素，求直接后继\"&lt;&lt;endl; cout&lt;&lt;\"8.在第i个位置插入元素\"&lt;&lt;endl; cout&lt;&lt;\"9.删除第i个元素\"&lt;&lt;endl; cout&lt;&lt;\"10.输出所输入的链表元素\"&lt;&lt;endl; cout&lt;&lt;\"11.初始化并输入链表元素\"&lt;&lt;endl; cout&lt;&lt;\"12.退出\"&lt;&lt;endl; cout&lt;&lt;\"13.判断单链表是否为空\"&lt;&lt;endl; cout&lt;&lt;\"14.链表逆转\"&lt;&lt;endl; cout&lt;&lt;\"********************\"&lt;&lt;endl; cout&lt;&lt;\"请输入你的选择：\";&#125;//判断输入是否合法bool IsInvalid(LinkList L)&#123; if(L==NULL) &#123; cout&lt;&lt;\"链表未初始化！\"&lt;&lt;endl; return true; &#125; else return false;&#125;int main()&#123; int k,s,i; ElemType e,res_e; LNode *p; LinkList L; PrintTips(); while(cin&gt;&gt;k) &#123; switch(k) &#123; case 1: s=InitList(L); if(s==1) cout&lt;&lt;\"初始化成功或重置成功！\"&lt;&lt;endl; break; case 2: s=DestoryList(L); if(s==1) cout&lt;&lt;\"销毁成功！\"&lt;&lt;endl; break; case 3: if(IsInvalid(L)) break; s=Listlength(L); cout&lt;&lt;\"链表中数据元素个数为：\"&lt;&lt;s&lt;&lt;endl; break; case 4: if(IsInvalid(L)) break; if(!L-&gt;next) &#123; cout&lt;&lt;\"链表为空！\"&lt;&lt;endl; break; &#125; cout&lt;&lt;\"请输入序号：\"; cin&gt;&gt;i; if(!GetElem(L,i,e)) &#123; cout&lt;&lt;\"该位置超出链表范围！\"&lt;&lt;endl; break; &#125; cout&lt;&lt;\"下标\"&lt;&lt;i&lt;&lt;\"处元素值为：\"&lt;&lt;e&lt;&lt;endl; break; case 5: if(IsInvalid(L)) break; cout&lt;&lt;\"请输入要查找的元素：\"; cin&gt;&gt;e; s=LocateElem(L,e); if(!s) &#123; cout&lt;&lt;\"不存在\"&lt;&lt;endl; break; &#125; cout&lt;&lt;\"值为\"&lt;&lt;e&lt;&lt;\"的元素下标为：\"&lt;&lt;s&lt;&lt;endl; break; case 6: if(IsInvalid(L)) break; if(!L-&gt;next) &#123; cout&lt;&lt;\"链表为空！\"&lt;&lt;endl; break; &#125; cout&lt;&lt;\"请输入一个元素：\"; cin&gt;&gt;e; if(!PriorElem(L,e,res_e)) &#123; cout&lt;&lt;\"查找失败！\"&lt;&lt;endl; break; &#125; cout&lt;&lt;\"该元素的前驱为：\"&lt;&lt;res_e&lt;&lt;endl; break; case 7: if(IsInvalid(L)) break; if(!L-&gt;next) &#123; cout&lt;&lt;\"链表为空！\"&lt;&lt;endl; break; &#125; cout&lt;&lt;\"请输入一个元素：\"; cin&gt;&gt;e; if(!NextElem(L,e,res_e)) &#123; cout&lt;&lt;\"查找失败！\"&lt;&lt;endl; break; &#125; cout&lt;&lt;\"该元素的后继为：\"&lt;&lt;res_e&lt;&lt;endl; break; case 8: if(IsInvalid(L)) break; cout&lt;&lt;\"请输入要插入的位置和元素：\"; cin&gt;&gt;i&gt;&gt;e; s=ListInsert(L,i,e); if(s) cout&lt;&lt;\"插入成功！\"&lt;&lt;endl; else cout&lt;&lt;\"插入失败！\"&lt;&lt;endl; break; case 9: if(IsInvalid(L)) break; cout&lt;&lt;\"请输入要删除的位置：\"; cin&gt;&gt;i; s=ListDelete(L,i,e); if(s) cout&lt;&lt;\"删除成功！,该位置值为：\"&lt;&lt;e&lt;&lt;endl; else cout&lt;&lt;\"删除失败！\"&lt;&lt;endl; break; case 10: if(IsInvalid(L)) break; LinkPrint(L); cout&lt;&lt;endl; break; case 11: cout&lt;&lt;\"请输入要插入链表的元素个数：\"; cin&gt;&gt;s; CreateList_R(L,s); break; case 12: return 0; break; case 13: if(IsInvalid(L)) break; if(IsEmpty(L)) cout&lt;&lt;\"链表为空！\"&lt;&lt;endl; else cout&lt;&lt;\"非空！\"&lt;&lt;endl; break; case 14: if(IsInvalid(L)) break; if(ReverseList(L)) cout&lt;&lt;\"链表逆转成功！\"&lt;&lt;endl; else cout&lt;&lt;\"操作失败！\"&lt;&lt;endl; break; default: cout&lt;&lt;\"操作有误！\"&lt;&lt;endl; &#125; cout&lt;&lt;\"请输入你的选择：\"; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"C++构建自己的计算机 ，C++机器语言程序","slug":"C++构建自己的计算机 ，C++机器语言程序","date":"2021-04-07T11:28:49.563Z","updated":"2021-05-22T15:39:34.519Z","comments":true,"path":"posts/1290/","link":"","permalink":"https://blog.liph.top/posts/1290/","excerpt":"","text":"写在前面题目出自《c++大学教程第五版》需要建立一个称为Simpletron的计算机，其中所有的信息都是由带符号的4位十进制数组成的“字”来助理，前两位是操作码，之后的两位是内存位置，需要将各操作码的功能实现，话不多说，直接上代码 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;string.h&gt;using namespace std;void pusherror();//抛出错误void halt();//寄存器与内存信息void start();//输出程序启动信息void action(int,int,int);//执行各指令void input();//输入指令字并提取信息int memory[100];//内存int acc=0;//累加寄存器，初始化为0int counter;//下一个内存位置int operand;//内存位置int operationCode;//指令string instructionRegister=\"+0000\";//命令字//主函数int main()&#123; start(); input(); return 0;&#125;void start() //输出开机内容&#123; cout &lt;&lt; \"*** Welcome to Simpletron! ***\" &lt;&lt; endl &lt;&lt; \"*** Please enter your program one instruction ***\" &lt;&lt; endl; cout &lt;&lt; \"*** (or data word) at a time.I will type the ***\" &lt;&lt; endl &lt;&lt; \"*** location number and a question mark(? ). ***&lt;&lt;endl\"; cout &lt;&lt; \"*** You then type the word for that location. ***\" &lt;&lt; endl &lt;&lt; \"*** Type the sentinel - 99999 to stop entering ***\" &lt;&lt; endl; cout &lt;&lt; \"*** your program. ***\" &lt;&lt; endl;&#125;void pusherror()//打印错误信息&#123; cout &lt;&lt; \"*** Attempt to divide by zero ***\" &lt;&lt; endl; cout &lt;&lt; \"*** Simpletron execution abnormally terminated ***\" &lt;&lt; endl; halt(); input();&#125;void halt()//输出内存的全部内容&#123; string sp = \" \"; cout &lt;&lt; \"REGISTERS\" &lt;&lt; endl;//输出各寄存器中的值 cout &lt;&lt; resetiosflags(ios::right); cout &lt;&lt; setiosflags(ios::left) &lt;&lt; setw(20) &lt;&lt; \"accumlator\" &lt;&lt; setiosflags(ios::right) &lt;&lt; setw(6) &lt;&lt; \"+\" &lt;&lt; setw(4) &lt;&lt; setfill('0') &lt;&lt; acc &lt;&lt; setfill(' ') &lt;&lt; endl; cout &lt;&lt; resetiosflags(ios::right) &lt;&lt; setw(20) &lt;&lt; \"counter\" &lt;&lt; setiosflags(ios::right) &lt;&lt; sp &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; counter &lt;&lt; setfill(' ') &lt;&lt; endl; cout &lt;&lt; resetiosflags(ios::right) &lt;&lt; setw(20) &lt;&lt; \"instructionRegister\" &lt;&lt; setiosflags(ios::right) &lt;&lt; setw(10) &lt;&lt; instructionRegister &lt;&lt; endl; cout &lt;&lt; resetiosflags(ios::right) &lt;&lt; setw(20) &lt;&lt; \"operationCode\" &lt;&lt; setiosflags(ios::right) &lt;&lt; sp &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; operationCode &lt;&lt; setfill(' ') &lt;&lt; endl; cout &lt;&lt; resetiosflags(ios::right) &lt;&lt; setw(20) &lt;&lt; \"operand\" &lt;&lt; setiosflags(ios::right) &lt;&lt; sp &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; operand &lt;&lt; setfill(' ') &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; \"MEMORY:\" &lt;&lt; endl; cout &lt;&lt; \" \"; for (int i = 0; i &lt; 10; i++) //输出内存中内容 &#123; cout &lt;&lt; setiosflags(ios::right) &lt;&lt; setw(6) &lt;&lt; i; &#125; cout &lt;&lt; endl &lt;&lt; \" 0\"; int k = 0; for (int i = 0; i &lt; 100; i++) &#123; if (k &gt; 0 &amp;&amp; k % 10 == 0) cout &lt;&lt; endl &lt;&lt; setw(2) &lt;&lt; setfill(' ') &lt;&lt; k; cout &lt;&lt; \" +\" &lt;&lt; setw(4) &lt;&lt; setfill('0') &lt;&lt; memory[i]; k++; &#125; cout &lt;&lt; endl; input();&#125;void action(int op, int p, int n) //根据指令进行对应操作&#123; counter = p; operationCode = op; operand = p; if (n &lt; -9999 || n&gt;9999) pusherror(); switch (op) &#123; case 10: //从键盘中读入值到内存中指定位置 memory[p] = n; input(); break; case 11: //输出内存中指定位置的值 cout &lt;&lt; memory[p] &lt;&lt; endl; input(); break; case 20: //将内存中指定位置的值载入累加器 acc = memory[p]; input(); break; case 21: //将累加器中的值存储在内存中指定位置 memory[p] = acc; input(); break; case 30: //累加器加值 acc += memory[p]; input(); break; case 31: //累加器减值 acc -= memory[p]; input(); break; case 32: //累加器除值 if (memory[p] == 0) pusherror(); acc /= memory[p]; input(); break; case 33: //累加器乘值 acc *= memory[p]; input(); break; case 40: //转移到内存中特定位置 memory[p] = acc; counter = operand; input(); break; case 41: //累加器如为负，转移至内存 if (acc &lt; 0) &#123; memory[p] = acc; acc = 0; &#125; input(); break; case 42: //累加器如为零，转移至内存 if (acc == 0) &#123; memory[p] = acc; acc = 0; &#125; input(); break; default://结束程序 cout &lt;&lt; \"你的输入有误，请重新输入！\" &lt;&lt; endl; input(); &#125;&#125;void input() //输入并提取有效信息&#123; cout &lt;&lt; \"? \"; string in; getline(cin, in); if (in.compare(\"halt\") != 0) instructionRegister.assign(in); string::size_type k = in.find('+');//查找输入项中的“+”号，判断输入是否符合语法 string::size_type l = in.find(\"halt\"); if (l != string::npos) halt(); else if (k == string::npos) &#123; cout &lt;&lt; \"你的输入有误!请重新输入\" &lt;&lt; endl; input(); &#125; string order = in.substr(1, 2);//order是输入项中所含指令 string x, n; x = in.substr(3, 2);//x为储存位置 if (in.length() &gt; 5)//获取操作数 n = in.substr(5); else n = \"0\"; int d = stoi(n);//将n,order转化为整数 int c = stoi(x);//将内存位置转化为整数存储在count中 int iorder = stoi(order); if (c &lt; 0 || c&gt;99) pusherror(); if (iorder == 43) &#123; cout &lt;&lt; \"*** Program end. ***\" &lt;&lt; endl; return; &#125; action(iorder, c, d);&#125; 题目算法难度不大，需要多注意细节，不要掉坑哦","categories":[],"tags":[]},{"title":"107网站工作室简介","slug":"107网站工作室简介","date":"2021-04-07T11:28:49.562Z","updated":"2021-05-22T15:39:51.267Z","comments":true,"path":"posts/43173/","link":"","permalink":"https://blog.liph.top/posts/43173/","excerpt":"","text":"1.实验室是干什么的？？简单来说就是写网站的，学院官网和其他部分学院官网均出自107网站工作室。 2.学习内容难不难，我是小白怎么办？？我们实验室招的就是小白，我们会给大家发些学习视频等资源，只要大家认真观看并付诸行动，脱离小白不是梦。 3.进实验室我能得到些什么？？ 平常不仅会教大家网站方面的技能也会在电脑使用技巧等方面竭力帮助大家。于本人而言，这是我对计算机的一个启蒙。 写网站可培养逻辑能力，网站文件的结构布局和大量代码的编写对日后专业课的学习非常有帮助。 赚点外快，努力点挣个学费完全没问题。 进实验室能有自己的专属座位，实验室在学院202，有空调，不用再去图书馆占位了。 每年实验室负责人可获得360免简历筛选直接面试的资格。 4.寄语无论大家是选择107实验室还是其他实验室，一定要选择一个实验室并认真学习，差距往往就是不经意间拉开的。","categories":[],"tags":[]}],"categories":[],"tags":[]}