{"meta":{"title":"煮酒の博客","subtitle":"欢迎加入","description":"煮酒","author":"煮酒","url":"https://lipenghuihenu.gitee.io","root":"/"},"pages":[{"title":"关于我的","date":"2020-07-25T12:34:27.000Z","updated":"2021-04-07T13:30:55.319Z","comments":true,"path":"about/index.html","permalink":"https://lipenghuihenu.gitee.io/about/index.html","excerpt":"","text":"关于博主博主是编程学生党一枚，主要学习过如下技术 前端 后端 html,css,js,vue,react,koa,taro,webpack,typescript,Sass，MongoDB JAVA,Servlet2.0/3.0,MySQL,Spring全家桶,Redis,Mybatis,Hibernate,Struts,简单算法,简单数据结构,设计模式"},{"title":"分类","date":"2020-07-25T12:29:35.000Z","updated":"2021-04-07T11:28:49.567Z","comments":true,"path":"categories/index.html","permalink":"https://lipenghuihenu.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-07-25T12:30:26.000Z","updated":"2021-04-07T11:28:49.569Z","comments":true,"path":"link/index.html","permalink":"https://lipenghuihenu.gitee.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-07-25T12:28:15.000Z","updated":"2021-04-07T11:28:49.571Z","comments":true,"path":"tags/index.html","permalink":"https://lipenghuihenu.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"第一次考核常见问题及知识点总结","slug":"第一次考核常见问题及知识点总结","date":"2021-04-08T06:18:51.000Z","updated":"2021-05-22T15:40:04.523Z","comments":true,"path":"posts/58104/","link":"","permalink":"https://lipenghuihenu.gitee.io/posts/58104/","excerpt":"","text":"第一次考核已经结束，我们也看了大家的作业，总体来说基本大模样都能写出来，但都存在着这样那样的小问题，大家刚接触这也很正常，下面汇集了大家常见的问题，希望能对大家有所帮助 问题1. 图片写成绝对路径，导致发来的作业我们打开看不到你的图片例如路径写成&lt;img src= &quot;C:/Users/test/Documents/images/logo.png&quot;&gt;而发来后我们打开网页，网页会去找我们的C盘下的这个文件，而我们C盘又没有这个文件导致图片不能显示。解决方法：以后图片路径一律写成相对路径，如../images/logo.png这样也方便移动文件后也能正常打开。 2.文件夹层次较乱部分同学所有文件在同一文件夹下，这样就会显着很没有层次，以后文件会很多就会显得杂乱无章解决方法:图片统一在images(也可以取其他名字，但要能一看就知道是放图片的)文件夹下类似的文件统一在一个文件夹下这种，css放到单独的css文件夹下，下面提供一种方案。 3. 缩放后跑到一个方向而不是居中如何快速缩放：按住Ctrl键滚动鼠标放大缩小例如下面这种，缩小后内容跑到一边，另一边留下大面积空白 解决方法：margin:auto；让其自动居中，具体实现另行讲解。 4. 字体颜色距离与原图差异较大如果字体距离与原图不同但界面美观也行，但部分同学因字体颜色距离等因素导致界面看起来不美观。目前大家处于模仿阶段，务必做到与原图一模一样，不要觉得差不多就退而求其次。这是非常严重的问题。解决方法：仔细对比原图，我个人用qq自带截图Ctrl+Alt+A，找到需要的颜色的rgb值，然后使用rgb格式加上颜色，例如color:rgb(123,123,123)双击数值然后按住键盘上的上下可即时调节(在网页上可即时看到效果) 5. 出现横向滚动条了怎么办看了下很多人出现了这个问题，原因大多是比如你用了太大的宽度让他沾满整个屏幕，如果你用的台式机显示正常，你看着挺好，但是比如我电脑14寸的，宽度总共就1000多px，你来个500不出问题才怪。按住F12选中某个盒子是经常用到的排查错误的方式解决方法： 按F12然后点击左边的小鼠标（google chrome快捷键Ctrl+Shift+C）放到右面空白的地方看看是哪个div太宽了导致出现滚动条 根本解决方法是margin:auto配合左右浮动+外层用百分比 6.css代码放到html文件里并不是说css和html放一起就是错的，而是如果css代码较多就会显得文章比较乱（假想你要向下一直滑才能看到你的html代码是什么感觉）放一个文件里只适合css代码较少这样比较好维护解决方法：采用引用外部文件的形式 7.好多同学都是用table写的并不是说用table写是错的，而是table一方面不容易维护，一些框架也都是用div加其他的完成的，日后除后端表格外一般不会用到table解决方法：强烈建议大家用div写 8.咨询建议是固定在窗口固定位置的部分同学的咨询建议那不会随着页面滚动而改变位置解决方法：参考下源码中的效果，主要就是position: fixed; 9.部分同学写死宽度这里指的是比如你写一个盒子宽1500px,你的电脑比较宽看着没问题，但是放到小点的电脑1500px太宽了就会出现滚动条 解决方法：对于较大的宽度用百分比表示(一般在&lt;head&gt;、&lt;footer&gt;这种外层框架才会用到) 知识点1. margin:0 auto；配合左右浮动红色框的宽度固定假如为1000px;再加个margin: 0 auto; 让红色框水平方向居中；再加个overflow: hidden;清除文档流的浮动，避免红色框以外的元素随着里面元素的浮动里面的两个黑色框宽度固定但不要超过父元素宽度，一个float:left, 一个float:right;如果黑色框里还有这种左右结构，可以继续将其进行拆分按照这个方式 布局就能让网页在不同大小的屏幕（电脑屏幕）或不同浏览器上浏览排版不乱 2.浮动float浮动在初学时可能好多锅都是因为没用好浮动，比如怎么盒子高度为0。具体参考CSS浮动：W3school的css浮动 3.改了代码却不生效这种问题可能是代码没写好，但有时代码没什么问题，却还是不生效。这是因为浏览器的缓存机制的问题。浏览器为了节省流量和更快的打开网页，在用户多次刷新时并不会重新刷新所有文件，而只是刷新部分文件，这就导致可能你改动的代码并未被浏览器重新引用。解决方法：清除浏览器数据 也可在网页界面按快捷键Ctrl+F5谷歌浏览器是这样，其他浏览器类似 4.如何自适应我看了下大多数人都没有用到margin:auto,可能你是用的padding-left或margin-left或绝对定位（虽然可以居中,但是麻烦）使得在你自己电脑上看着好像居中了。比如下面这张图: 左边的logo部分就用的padding-left:130px;,在你的电脑上看着距离挺合适和原图差不多。 但是当你缩放时这时logo这部分距离左边仍然是130px,这就会造成整体左移. 那如何让它居中呢，这时缩放时你应该让它距左边不能是130px了，而应该是一个更大的值，但是如果你写死宽度，就不能做到然他自动变化，所以就要用到margin:auto.具体怎么用margin:auto参考左右浮动布局讲解或网上自行查找资料（必须学会用居中！！！） 小结本篇文章并不能包含所有大家遇到的问题，有些问题也需要大家自己去搜索解决。文章为个人经验所写，如有错误，可在评论区留言，祝大家学习愉快。","categories":[],"tags":[]},{"title":"Hadoop MapReduce概述","slug":"Hadoop MapReduce概述","date":"2021-04-08T06:10:16.304Z","updated":"2021-05-22T15:36:18.212Z","comments":true,"path":"posts/42300/","link":"","permalink":"https://lipenghuihenu.gitee.io/posts/42300/","excerpt":"","text":"概述MapReduce是一种并行编程模型，用于大规模数据集的并行运算，将复杂的、运行于大规模集群上的并行计算过程高度抽象到两个函数：Map和Reduce，极大的方便了分布式编程工作，对不会分布式并行编程的人员十分友好。 MapReduce将复杂的、运行于大规模集群上的并行计算过程高度抽象到两个函数：Map和Reduce，在MapReduce中，一个存储在分布式文件系统中的大规模数据集会被切分成许多独立的数据块，这些数据块可以被多个Map任务并行处理。需要注意的是，适合用MapReduce来处理的数据集需要满足一个前提条件：待处理的数据集可以分解成许多小的数据集，而且每一个数据集都可以完全并行地进行处理。 MapReduce的一个设计理念是“计算向数据靠拢”，而不是“数据向计算靠拢”，因此，在一个集群中，MapReduce会尽量将Map程序就近的在HDFS数据所在的节点运行，即将计算节点和存储节点放在一起运行，从而减少了节点间的数据移动。 MapReduce工作流程MapReduce的核心思想可以用“分而治之”来形容，即把大量的数据集拆分成多个小的数据块在多台机器上并行处理，以下是MapReduce执行的过程： 使用InputFormat模块做Map前的预处理，比如验证输入的格式是否符合输入定义，然后将文件切分成逻辑上的多个InputSplit（MapReduce对文件进行处理和运算的输入单位，只是一个逻辑概念，并没有对文件做实际切割，只是记录了要处理的数据的位置和长度）。 通过RecordReader根据InputSplit中的信息来处理InputSplit中的具体记录，加载数据并转换为适合Map任务读取的键值对，输入给Map任务。 Map任务根据用户自定义的映射规则，输出一系列的&lt;key,value&gt;作为中间结果。 对Map的输出进行一定的分区（Portition），排序(Sort)，合并(Combine)，归并（Merge），得到&lt;key,value-list&gt;形式的中间结果，以使Reduce可以并行的处理Map的结果，从无序的&lt;key,value&gt;到有序的&lt;key,value-list&gt;,这个过程称为Shuffle。 Reduce以一系列的&lt;key,value-list&gt;中间结果作为输入，执行用户定义的逻辑，输出结果给OutputFormat模块。 OutputFormat模块验证输出目录是否已经存在及输出结果类型是否符合配置文件中的配置类型，验证通过则输出Reduce的结果到分布式文件系统。 Shuffle过程Shuffle是指对Map输出结果进行分区、排序、合并等处理并交给Reduce的过程，分为Map端的Shuffle过程和Reduce端的Shuffle过程。 Map端的Shuffle过程Map端的Shuffle过程包括四个过程： 输入数据和执行Map任务Map任务接受&lt;key,value&gt;作为输入后，按一定的映射规则转换成一批&lt;key，value&gt; 写入缓存每个Map任务都会被分配一个缓存，Map的输出结果首先写入缓存，在缓存中积累一定数量的Map输出结果后，在一次性批量写入磁盘，在写入缓存之前，key和value值都会被序列化成字节数组 溢写（分区、排序和合并）MapReduce的缓存容量有限，当缓存中的Map结果不断增加时，需要启动溢写操作，将缓存中的内容一次性写入磁盘，并清空缓存，不能等到缓存全部沾满后才启动溢写过程，一般会设置一个溢写比例，如0.8，当缓存占用空间达到这个比例时，就启动溢写操作。在溢写到磁盘之前，缓存中的数据需经历一下几个过程：分区、排序、合并（可选）。MapReduce通过Partitioner接口对键值对进行分区，将Map的结果均匀的分配到Reduce任务进行并行处理，MapReduce允许用户通过重载Partitioner接口来自定义分区方式。对于每个分区内的所有键值对，后台线程会根据key对他们进行内存排序。排序结束后，包含一个可选的合并（Combine）操作，只有在用户定义了Combiner函数时，才会进行合并操作，将具有相同key的&lt;key,value&gt;的value求和，以减少键值对的数量。 文件归并每次溢写操作都会在磁盘中生成一个溢写文件，溢写文件的数量会随着MapReduce任务的执行而越来越多，在Map任务全部结束之前，系统会对所有溢写文件中的数据进行归并，将具有相同key的键值对归并成一个新的键值对，生成一个大的溢写文件。Reduce端的Shuffle过程相对于Map端的Shuffle过程，Reduce端的Shuffle过程更为简单，只需从Map端读取Map结果，并执行归并操作，然后输送给Reduce任务进行处理Reduce端的Shuffle过程包括三个步骤： “领取”数据Map端的Shuffle过程结速后，Reduce任务需要把Map的输出结果“领取”（fetch）来存放到自己所在机器的本地磁盘上，在Reduce任务真正开始前，大部分时间都在从Map端“领取”属于自己处理的分区数据。 归并数据从Map端领回的数据首先被存放在Reduce任务所在机器的缓存中，当缓存被沾满时，数据会被溢写到磁盘中，在溢写过程中会进行与Map端的shuffle过程类似的排序和合并操作。 把数据输入给Reduce任务磁盘中经过多轮归并后得到若干个大文件，不会继续归并成一个新的大文件，而是直接输入给Reduce任务，以减少磁盘读写开销","categories":[],"tags":[]},{"title":"科学上网教程","slug":"科学上网教程","date":"2021-04-07T11:28:49.565Z","updated":"2021-05-22T15:40:12.191Z","comments":true,"path":"posts/45527/","link":"","permalink":"https://lipenghuihenu.gitee.io/posts/45527/","excerpt":"","text":"说明科学上网：即翻墙访问外网，本教程仅介绍免费翻墙技巧，在速度和流量上有限制，但是不追求YouTube 4K画质够用了，白嫖党的福利，氪金大佬可充钱，这里主要介绍我目前在用的V2ray 速度截图这是YouTube 4K视频的速度，这个速度相当不错了，全程无卡顿，在GitHub下载文件也是相当快，可以满足大部分需求 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传 服务器节点V2ray主要使用各种服务器节点，有许多经销商，一般都有免费的节点，追求速度的可以氪金 接下来就是几个现在常用的提供商，大家看那个好用就用那个，一般是一个节点不行了就换一个 自由人士免费节点： 注册链接：http://freeperson.xyz/auth/register CLAPSE注册送10G，7天后流量清零，过期后可选择3块或6块一个月的套餐，相对来说比较便宜 我的已经过期了，就不放截图了 注册链接：https://www.clapse.com/ MGNB注册送300g，两天后到期，不用代理，续费一月五毛，速度很快 免费节点： 注册链接：https://mgnb.vip/#/register 小塞 SEBS注册送20G,有效期20天 注册链接：https://ggboom.site/ 节点使用教程有了服务器节点，怎么用呢，慢慢往下看 客户端下载下载V2ray客户端，解压后找到V2ray.exe双击即可打开代理，建议发送快捷方式到桌面 点我下载客户端 配置节点下载好后去复制订阅链接，这里使用自有人士 复制订阅链接后粘贴到浏览器网址栏，下载txt文档，Ctrl+A复制txt文档中的内容，打开V2ray程序，右击，选择从剪贴板批量导入URL 再次右击V2ray程序，即可选择服务器，选择其中一个即可实现科学上网 寻找服务器节点的方法以上节点是在YouTube上看到的，类似的还有很多，有需求的可以自己去搜，有很多人专门分享的 SSRssr俗称小飞机，和V2ray类似，但是V2ray目前比较稳定，这里就不对ssr作介绍了 写在最后很多服务器节点每天签到送流量，大家可以偶尔签到，不然流量可能不够用 以上教程为电脑端使用，手机端上述节点提供商也有相应程序可以下载，可以使用同样的节点 写在最后 很多服务器节点每天签到送流量，大家可以偶尔签到，不然流量可能不够用 以上教程为电脑端使用，手机端上述节点提供商也有相应程序可以下载，可以使用同样的节点 在配置过程中，大家有什么问题可以在评论区留言","categories":[],"tags":[]},{"title":"sublime 、 vscode 快捷生成HTML代码","slug":"sublime 、 vscode 快捷生成HTML代码","date":"2021-04-07T11:28:49.564Z","updated":"2021-05-22T15:36:06.664Z","comments":true,"path":"posts/3541/","link":"","permalink":"https://lipenghuihenu.gitee.io/posts/3541/","excerpt":"","text":"文章转载自https://www.cnblogs.com/suitongyu/p/12043791.html 基本html结构输入 !+Enter 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 生成div加类名的快捷键输入 div.list&gt;div.item_$*6 12345678&lt;div class=\"list\"&gt; &lt;div class=\"item_1\"&gt;&lt;/div&gt; &lt;div class=\"item_2\"&gt;&lt;/div&gt; &lt;div class=\"item_3\"&gt;&lt;/div&gt; &lt;div class=\"item_4\"&gt;&lt;/div&gt; &lt;div class=\"item_5\"&gt;&lt;/div&gt; &lt;div class=\"item_6\"&gt;&lt;/div&gt;&lt;/div&gt; 带类名的div输入 div.wrapper 1&lt;div class=\"wrapper\"&gt;&lt;/div&gt; 带id的divdiv#wrapper 1&lt;div id=\"wrapper\"&gt;&lt;/div&gt; 属性 []span[title=”test”] 1&lt;span title=\"test\"&gt;&lt;/span&gt; 后代 &gt;输入div&gt;span&gt;a 1&lt;div&gt;&lt;span&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt; 兄弟 +div+p+span 123&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;span&gt;&lt;/span&gt; 上级 ^div&gt;span^i 12&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;i&gt;&lt;/i&gt; 乘法 *ul&gt;li*2 1234&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 文本 {}div&gt;span{this is test} 1&lt;div&gt;&lt;span&gt;this is test&lt;/span&gt;&lt;/div&gt; 自增符 $ul&gt;li.list_${list $}*3 12345&lt;ul&gt; &lt;li class=\"list_1\"&gt;list 1&lt;/li&gt; &lt;li class=\"list_2\"&gt;list 2&lt;/li&gt; &lt;li class=\"list_3\"&gt;list 3&lt;/li&gt;&lt;/ul&gt; ul&gt;li.item$@3*3 “@3” （表示从3开始计数） 12345&lt;ul&gt; &lt;li class=\"item3\"&gt;list 1&lt;/li&gt; &lt;li class=\"item4\"&gt;list 2&lt;/li&gt; &lt;li class=\"item5\"&gt;list 3&lt;/li&gt;&lt;/ul&gt; 隐式转换.class 1&lt;div class=\"class\"&gt;&lt;/div&gt; ul&gt;.item 123&lt;ul&gt; &lt;li class=\"item\"&gt;&lt;/li&gt;&lt;/ul&gt; table&gt;.row&gt;.col 12345&lt;table&gt; &lt;tr class=\"row\"&gt; &lt;td class=\"col\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;","categories":[],"tags":[]},{"title":"数据结构——单链表的基本操作","slug":"数据结构——单链表的基本操作","date":"2021-04-07T11:28:49.564Z","updated":"2021-05-22T15:40:17.345Z","comments":true,"path":"posts/14136/","link":"","permalink":"https://lipenghuihenu.gitee.io/posts/14136/","excerpt":"","text":"实验目的通过该实验，深入理解链表的逻辑结构、物理结构等概念，掌握链表基本操作的编程实现，熟练掌握C语言中指针的操作。 实验内容编程实现链表下教材第二章定义的线性表的基本操作，最好用菜单形式对应各个操作，使其编程一个完整的小软件。 参考界面： 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389#include &lt;iostream&gt;using namespace std;typedef int ElemType;typedef struct LNode&#123; ElemType data; struct LNode *next;&#125;LNode,*LinkList;//链表初始化int InitList(LinkList &amp;L)&#123; L=new LNode; if(!L) return 0; L-&gt;next=NULL; return 1;&#125;//销毁链表int DestoryList(LinkList &amp;L)&#123; LinkList p; while(L) &#123; p=L; L=L-&gt;next; delete p; &#125; return 1;&#125;//清空单链表int ClearList(LinkList L)&#123; LinkList p,q; p=L-&gt;next; while(p)&#123;q=p;delete q;p=p-&gt;next;&#125; L-&gt;next=NULL; return 1;&#125;//求单链表长度int Listlength(LinkList L)&#123; int sum=0; LinkList p=L-&gt;next; while(p) &#123; p=p-&gt;next; sum++; &#125; return sum;&#125;//判断单链表是否为空bool ListEmpty(LinkList L)&#123; if(L-&gt;next) return 1; else return 0;&#125;//获取单链表中某个数据元素的内容int GetElem(LinkList L,int i,ElemType &amp;e)&#123; LinkList p=L-&gt;next; int j=1; while(p&amp;&amp;j&lt;i) &#123; p=p-&gt;next; ++j; &#125; if(!p||j&gt;i)return 0; e=p-&gt;data; return 1;&#125;//查找值为e的数据元素的位置int LocateElem(LinkList L,ElemType e)&#123; LinkList p=L-&gt;next; int i=0; while(p&amp;&amp;p-&gt;data!=e) &#123; p=p-&gt;next; i++; &#125; if(i&gt;=Listlength(L)) return 0; return i+1;&#125;//求直接前驱int PriorElem(LinkList L,ElemType e,ElemType&amp;pre_e)&#123; LNode*p=L-&gt;next; if(e==p-&gt;data) return 0; while(p-&gt;next) &#123; if(p-&gt;next-&gt;data==e) &#123; pre_e=p-&gt;data; return 1; &#125; p=p-&gt;next; &#125; return 0;&#125;//求直接后继int NextElem(LinkList L,ElemType e,ElemType&amp;next_e)&#123; LNode*p=L-&gt;next; while(p) &#123; if(p-&gt;data==e&amp;&amp;p-&gt;next) &#123; next_e=p-&gt;next-&gt;data; return 1; &#125; p=p-&gt;next; &#125; return 0;&#125;//在单链表中插入数据元素int ListInsert(LinkList&amp;L,int i,ElemType e)&#123; LinkList p=L; int j=0; while(p&amp;&amp;(j&lt;i-1)) &#123; p=p-&gt;next; ++j; &#125; if(!p||j&gt;i-1)return 0; LinkList s=new LNode; s-&gt;data=e; s-&gt;next=p-&gt;next; p-&gt;next=s; return 1;&#125;//删除单链表中第i个元素，返回第i个元素的值int ListDelete(LinkList &amp;L,int i,ElemType&amp;e)&#123; LinkList p=L; int j=0; while((p-&gt;next)&amp;&amp;(j&lt;i-1)) &#123; p=p-&gt;next; ++j; &#125; if(!(p-&gt;next)||(j&gt;i-1)) return 0; LinkList q=p-&gt;next; e=q-&gt;data; p-&gt;next=q-&gt;next; delete q; return 1;&#125;//输出链表元素void LinkPrint(LinkList &amp;L)&#123; LinkList p=L-&gt;next; while(p) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;\" \"; p=p-&gt;next; &#125;&#125;//前插法创建单链表void CreateList_H(LinkList &amp;L,int n)&#123; L=new LNode; L-&gt;next=NULL; cout&lt;&lt;\"请输入要插入的元素:\"&lt;&lt;endl; for(int i=0;i&lt;n;i++) &#123; LNode*p=new LNode; cin&gt;&gt;p-&gt;data; p-&gt;next=L-&gt;next; L-&gt;next=p; &#125;&#125;//后插法创建单链表void CreateList_R(LinkList&amp;L,int n)&#123; L=new LNode; L-&gt;next=NULL; LNode*r=L; for(int i=0;i&lt;n;++i) &#123; LinkList p=new LNode; cin&gt;&gt;p-&gt;data; p-&gt;next=NULL; r-&gt;next=p; r=p; &#125;&#125;//判断链表是否为空bool IsEmpty(LinkList L)&#123; if(L-&gt;next) return false; else return true;&#125;//链表逆转int ReverseList(LinkList&amp;L)&#123; if(L==NULL||L-&gt;next==NULL) return 0; LinkList pRev=NULL; LinkList pCur=L-&gt;next; while(pCur!=NULL) &#123; LinkList temp=pCur; pCur=pCur-&gt;next; temp-&gt;next=pRev; pRev=temp; &#125; L-&gt;next=pRev; return 1;&#125;void PrintTips()&#123; cout&lt;&lt;\"可执行的操作有：\"&lt;&lt;endl; cout&lt;&lt;\"********************\"&lt;&lt;endl; cout&lt;&lt;\"1.初始化或重置列表\"&lt;&lt;endl; cout&lt;&lt;\"2.销毁链表\"&lt;&lt;endl; cout&lt;&lt;\"3.链表中数据元素的个数\"&lt;&lt;endl; cout&lt;&lt;\"4.所指位序的元素值\"&lt;&lt;endl; cout&lt;&lt;\"5.链表已存在元素的位序\"&lt;&lt;endl; cout&lt;&lt;\"6.请输入元素，求直接前驱\"&lt;&lt;endl; cout&lt;&lt;\"7.请输入元素，求直接后继\"&lt;&lt;endl; cout&lt;&lt;\"8.在第i个位置插入元素\"&lt;&lt;endl; cout&lt;&lt;\"9.删除第i个元素\"&lt;&lt;endl; cout&lt;&lt;\"10.输出所输入的链表元素\"&lt;&lt;endl; cout&lt;&lt;\"11.初始化并输入链表元素\"&lt;&lt;endl; cout&lt;&lt;\"12.退出\"&lt;&lt;endl; cout&lt;&lt;\"13.判断单链表是否为空\"&lt;&lt;endl; cout&lt;&lt;\"14.链表逆转\"&lt;&lt;endl; cout&lt;&lt;\"********************\"&lt;&lt;endl; cout&lt;&lt;\"请输入你的选择：\";&#125;//判断输入是否合法bool IsInvalid(LinkList L)&#123; if(L==NULL) &#123; cout&lt;&lt;\"链表未初始化！\"&lt;&lt;endl; return true; &#125; else return false;&#125;int main()&#123; int k,s,i; ElemType e,res_e; LNode *p; LinkList L; PrintTips(); while(cin&gt;&gt;k) &#123; switch(k) &#123; case 1: s=InitList(L); if(s==1) cout&lt;&lt;\"初始化成功或重置成功！\"&lt;&lt;endl; break; case 2: s=DestoryList(L); if(s==1) cout&lt;&lt;\"销毁成功！\"&lt;&lt;endl; break; case 3: if(IsInvalid(L)) break; s=Listlength(L); cout&lt;&lt;\"链表中数据元素个数为：\"&lt;&lt;s&lt;&lt;endl; break; case 4: if(IsInvalid(L)) break; if(!L-&gt;next) &#123; cout&lt;&lt;\"链表为空！\"&lt;&lt;endl; break; &#125; cout&lt;&lt;\"请输入序号：\"; cin&gt;&gt;i; if(!GetElem(L,i,e)) &#123; cout&lt;&lt;\"该位置超出链表范围！\"&lt;&lt;endl; break; &#125; cout&lt;&lt;\"下标\"&lt;&lt;i&lt;&lt;\"处元素值为：\"&lt;&lt;e&lt;&lt;endl; break; case 5: if(IsInvalid(L)) break; cout&lt;&lt;\"请输入要查找的元素：\"; cin&gt;&gt;e; s=LocateElem(L,e); if(!s) &#123; cout&lt;&lt;\"不存在\"&lt;&lt;endl; break; &#125; cout&lt;&lt;\"值为\"&lt;&lt;e&lt;&lt;\"的元素下标为：\"&lt;&lt;s&lt;&lt;endl; break; case 6: if(IsInvalid(L)) break; if(!L-&gt;next) &#123; cout&lt;&lt;\"链表为空！\"&lt;&lt;endl; break; &#125; cout&lt;&lt;\"请输入一个元素：\"; cin&gt;&gt;e; if(!PriorElem(L,e,res_e)) &#123; cout&lt;&lt;\"查找失败！\"&lt;&lt;endl; break; &#125; cout&lt;&lt;\"该元素的前驱为：\"&lt;&lt;res_e&lt;&lt;endl; break; case 7: if(IsInvalid(L)) break; if(!L-&gt;next) &#123; cout&lt;&lt;\"链表为空！\"&lt;&lt;endl; break; &#125; cout&lt;&lt;\"请输入一个元素：\"; cin&gt;&gt;e; if(!NextElem(L,e,res_e)) &#123; cout&lt;&lt;\"查找失败！\"&lt;&lt;endl; break; &#125; cout&lt;&lt;\"该元素的后继为：\"&lt;&lt;res_e&lt;&lt;endl; break; case 8: if(IsInvalid(L)) break; cout&lt;&lt;\"请输入要插入的位置和元素：\"; cin&gt;&gt;i&gt;&gt;e; s=ListInsert(L,i,e); if(s) cout&lt;&lt;\"插入成功！\"&lt;&lt;endl; else cout&lt;&lt;\"插入失败！\"&lt;&lt;endl; break; case 9: if(IsInvalid(L)) break; cout&lt;&lt;\"请输入要删除的位置：\"; cin&gt;&gt;i; s=ListDelete(L,i,e); if(s) cout&lt;&lt;\"删除成功！,该位置值为：\"&lt;&lt;e&lt;&lt;endl; else cout&lt;&lt;\"删除失败！\"&lt;&lt;endl; break; case 10: if(IsInvalid(L)) break; LinkPrint(L); cout&lt;&lt;endl; break; case 11: cout&lt;&lt;\"请输入要插入链表的元素个数：\"; cin&gt;&gt;s; CreateList_R(L,s); break; case 12: return 0; break; case 13: if(IsInvalid(L)) break; if(IsEmpty(L)) cout&lt;&lt;\"链表为空！\"&lt;&lt;endl; else cout&lt;&lt;\"非空！\"&lt;&lt;endl; break; case 14: if(IsInvalid(L)) break; if(ReverseList(L)) cout&lt;&lt;\"链表逆转成功！\"&lt;&lt;endl; else cout&lt;&lt;\"操作失败！\"&lt;&lt;endl; break; default: cout&lt;&lt;\"操作有误！\"&lt;&lt;endl; &#125; cout&lt;&lt;\"请输入你的选择：\"; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"C++构建自己的计算机 ，C++机器语言程序","slug":"C++构建自己的计算机 ，C++机器语言程序","date":"2021-04-07T11:28:49.563Z","updated":"2021-05-22T15:39:34.519Z","comments":true,"path":"posts/1290/","link":"","permalink":"https://lipenghuihenu.gitee.io/posts/1290/","excerpt":"","text":"写在前面题目出自《c++大学教程第五版》需要建立一个称为Simpletron的计算机，其中所有的信息都是由带符号的4位十进制数组成的“字”来助理，前两位是操作码，之后的两位是内存位置，需要将各操作码的功能实现，话不多说，直接上代码 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;string.h&gt;using namespace std;void pusherror();//抛出错误void halt();//寄存器与内存信息void start();//输出程序启动信息void action(int,int,int);//执行各指令void input();//输入指令字并提取信息int memory[100];//内存int acc=0;//累加寄存器，初始化为0int counter;//下一个内存位置int operand;//内存位置int operationCode;//指令string instructionRegister=\"+0000\";//命令字//主函数int main()&#123; start(); input(); return 0;&#125;void start() //输出开机内容&#123; cout &lt;&lt; \"*** Welcome to Simpletron! ***\" &lt;&lt; endl &lt;&lt; \"*** Please enter your program one instruction ***\" &lt;&lt; endl; cout &lt;&lt; \"*** (or data word) at a time.I will type the ***\" &lt;&lt; endl &lt;&lt; \"*** location number and a question mark(? ). ***&lt;&lt;endl\"; cout &lt;&lt; \"*** You then type the word for that location. ***\" &lt;&lt; endl &lt;&lt; \"*** Type the sentinel - 99999 to stop entering ***\" &lt;&lt; endl; cout &lt;&lt; \"*** your program. ***\" &lt;&lt; endl;&#125;void pusherror()//打印错误信息&#123; cout &lt;&lt; \"*** Attempt to divide by zero ***\" &lt;&lt; endl; cout &lt;&lt; \"*** Simpletron execution abnormally terminated ***\" &lt;&lt; endl; halt(); input();&#125;void halt()//输出内存的全部内容&#123; string sp = \" \"; cout &lt;&lt; \"REGISTERS\" &lt;&lt; endl;//输出各寄存器中的值 cout &lt;&lt; resetiosflags(ios::right); cout &lt;&lt; setiosflags(ios::left) &lt;&lt; setw(20) &lt;&lt; \"accumlator\" &lt;&lt; setiosflags(ios::right) &lt;&lt; setw(6) &lt;&lt; \"+\" &lt;&lt; setw(4) &lt;&lt; setfill('0') &lt;&lt; acc &lt;&lt; setfill(' ') &lt;&lt; endl; cout &lt;&lt; resetiosflags(ios::right) &lt;&lt; setw(20) &lt;&lt; \"counter\" &lt;&lt; setiosflags(ios::right) &lt;&lt; sp &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; counter &lt;&lt; setfill(' ') &lt;&lt; endl; cout &lt;&lt; resetiosflags(ios::right) &lt;&lt; setw(20) &lt;&lt; \"instructionRegister\" &lt;&lt; setiosflags(ios::right) &lt;&lt; setw(10) &lt;&lt; instructionRegister &lt;&lt; endl; cout &lt;&lt; resetiosflags(ios::right) &lt;&lt; setw(20) &lt;&lt; \"operationCode\" &lt;&lt; setiosflags(ios::right) &lt;&lt; sp &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; operationCode &lt;&lt; setfill(' ') &lt;&lt; endl; cout &lt;&lt; resetiosflags(ios::right) &lt;&lt; setw(20) &lt;&lt; \"operand\" &lt;&lt; setiosflags(ios::right) &lt;&lt; sp &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; operand &lt;&lt; setfill(' ') &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; \"MEMORY:\" &lt;&lt; endl; cout &lt;&lt; \" \"; for (int i = 0; i &lt; 10; i++) //输出内存中内容 &#123; cout &lt;&lt; setiosflags(ios::right) &lt;&lt; setw(6) &lt;&lt; i; &#125; cout &lt;&lt; endl &lt;&lt; \" 0\"; int k = 0; for (int i = 0; i &lt; 100; i++) &#123; if (k &gt; 0 &amp;&amp; k % 10 == 0) cout &lt;&lt; endl &lt;&lt; setw(2) &lt;&lt; setfill(' ') &lt;&lt; k; cout &lt;&lt; \" +\" &lt;&lt; setw(4) &lt;&lt; setfill('0') &lt;&lt; memory[i]; k++; &#125; cout &lt;&lt; endl; input();&#125;void action(int op, int p, int n) //根据指令进行对应操作&#123; counter = p; operationCode = op; operand = p; if (n &lt; -9999 || n&gt;9999) pusherror(); switch (op) &#123; case 10: //从键盘中读入值到内存中指定位置 memory[p] = n; input(); break; case 11: //输出内存中指定位置的值 cout &lt;&lt; memory[p] &lt;&lt; endl; input(); break; case 20: //将内存中指定位置的值载入累加器 acc = memory[p]; input(); break; case 21: //将累加器中的值存储在内存中指定位置 memory[p] = acc; input(); break; case 30: //累加器加值 acc += memory[p]; input(); break; case 31: //累加器减值 acc -= memory[p]; input(); break; case 32: //累加器除值 if (memory[p] == 0) pusherror(); acc /= memory[p]; input(); break; case 33: //累加器乘值 acc *= memory[p]; input(); break; case 40: //转移到内存中特定位置 memory[p] = acc; counter = operand; input(); break; case 41: //累加器如为负，转移至内存 if (acc &lt; 0) &#123; memory[p] = acc; acc = 0; &#125; input(); break; case 42: //累加器如为零，转移至内存 if (acc == 0) &#123; memory[p] = acc; acc = 0; &#125; input(); break; default://结束程序 cout &lt;&lt; \"你的输入有误，请重新输入！\" &lt;&lt; endl; input(); &#125;&#125;void input() //输入并提取有效信息&#123; cout &lt;&lt; \"? \"; string in; getline(cin, in); if (in.compare(\"halt\") != 0) instructionRegister.assign(in); string::size_type k = in.find('+');//查找输入项中的“+”号，判断输入是否符合语法 string::size_type l = in.find(\"halt\"); if (l != string::npos) halt(); else if (k == string::npos) &#123; cout &lt;&lt; \"你的输入有误!请重新输入\" &lt;&lt; endl; input(); &#125; string order = in.substr(1, 2);//order是输入项中所含指令 string x, n; x = in.substr(3, 2);//x为储存位置 if (in.length() &gt; 5)//获取操作数 n = in.substr(5); else n = \"0\"; int d = stoi(n);//将n,order转化为整数 int c = stoi(x);//将内存位置转化为整数存储在count中 int iorder = stoi(order); if (c &lt; 0 || c&gt;99) pusherror(); if (iorder == 43) &#123; cout &lt;&lt; \"*** Program end. ***\" &lt;&lt; endl; return; &#125; action(iorder, c, d);&#125; 题目算法难度不大，需要多注意细节，不要掉坑哦","categories":[],"tags":[]},{"title":"107网站工作室简介","slug":"107网站工作室简介","date":"2021-04-07T11:28:49.562Z","updated":"2021-05-22T15:39:51.267Z","comments":true,"path":"posts/43173/","link":"","permalink":"https://lipenghuihenu.gitee.io/posts/43173/","excerpt":"","text":"1.实验室是干什么的？？简单来说就是写网站的，学院官网和其他部分学院官网均出自107网站工作室。 2.学习内容难不难，我是小白怎么办？？我们实验室招的就是小白，我们会给大家发些学习视频等资源，只要大家认真观看并付诸行动，脱离小白不是梦。 3.进实验室我能得到些什么？？ 平常不仅会教大家网站方面的技能也会在电脑使用技巧等方面竭力帮助大家。于本人而言，这是我对计算机的一个启蒙。 写网站可培养逻辑能力，网站文件的结构布局和大量代码的编写对日后专业课的学习非常有帮助。 赚点外快，努力点挣个学费完全没问题。 进实验室能有自己的专属座位，实验室在学院202，有空调，不用再去图书馆占位了。 每年实验室负责人可获得360免简历筛选直接面试的资格。 4.寄语无论大家是选择107实验室还是其他实验室，一定要选择一个实验室并认真学习，差距往往就是不经意间拉开的。","categories":[],"tags":[]}],"categories":[],"tags":[]}